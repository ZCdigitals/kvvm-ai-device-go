package socket

import "testing"

func TestSocketHeader(t *testing.T) {
	t.Run("should parse right", func(t *testing.T) {
		data := []byte{
			0x12, 0x34, 0x56, 0x78, // id
			0x12, 0x34, 0x56, 0x79, // size
			0x12, 0x34, 0x56, 0x78, 0x12, 0x34, 0x56, 0x78, // timestamp
			0x12, 0x34, 0x56, 0x7a, // reserved 0
			0x12, 0x34, 0x56, 0x7a, // reserved 1
			0x12, 0x34, 0x56, 0x7a, // reserved 2
			0x12, 0x34, 0x56, 0x7a, // reserved 3
			0x12, 0x34, 0x56, 0x7a, // reserved 4
			0x12, 0x34, 0x56, 0x7a, // reserved 5
			0x12, 0x34, 0x56, 0x7a, // reserved 6
			0x12, 0x34, 0x56, 0x7a, // reserved 7
		}

		sh := ParseSocketHeader(data)

		if sh.ID != 0x78563412 {
			t.Errorf("id not match %d 0x78563412", sh.ID)
		}

		if sh.Size != 0x79563412 {
			t.Errorf("size not match %d 0x79563412", sh.Size)
		}

		if sh.Timestamp != 0x7856341278563412 {
			t.Errorf("timestamp not match %d 0x78563412", sh.Timestamp)
		}

		for i := range len(sh.Reserved) {
			if sh.Reserved[i] != 0x7a563412 {
				t.Errorf("reserved %d not match %d 0x7a563412", i, sh.Reserved[i])
			}
		}
	})

	t.Run("should be empty, because data not enough", func(t *testing.T) {
		data := []byte{
			0x12, 0x34, 0x56, 0x78, // id
			0x12, 0x34, 0x56, 0x79, // size
			0x12, 0x34, 0x56, 0x78, 0x12, 0x34, 0x56, 0x78, // timestamp
			0x12, 0x34, 0x56, 0x7a, // reserved 0
			0x12, 0x34, 0x56, 0x7a, // reserved 1
			0x12, 0x34, 0x56, 0x7a, // reserved 2
			0x12, 0x34, 0x56, 0x7a, // reserved 3
			0x12, 0x34, 0x56, 0x7a, // reserved 4
			0x12, 0x34, 0x56, 0x7a, // reserved 5
			0x12, 0x34, 0x56, 0x7a, // reserved 6
			0x12, 0x34, 0x56, // 0x7a, // reserved 7
		}

		sh := ParseSocketHeader(data)

		if sh.ID != 0 {
			t.Errorf("id not match %d 0", sh.ID)
		}

		if sh.Size != 0 {
			t.Errorf("size not match %d 0", sh.Size)
		}

		if sh.Timestamp != 0 {
			t.Errorf("timestamp not match %d 0", sh.Timestamp)
		}

		for i := range len(sh.Reserved) {
			if sh.Reserved[i] != 0 {
				t.Errorf("reserved %d not match %d 0", i, sh.Reserved[i])
			}
		}
	})
}

func BenchmarkSocketHeader(b *testing.B) {
	data := []byte{
		0x12, 0x34, 0x56, 0x78, // id
		0x12, 0x34, 0x56, 0x79, // size
		0x12, 0x34, 0x56, 0x78, 0x12, 0x34, 0x56, 0x78, // timestamp
		0x12, 0x34, 0x56, 0x7a, // reserved 0
		0x12, 0x34, 0x56, 0x7a, // reserved 1
		0x12, 0x34, 0x56, 0x7a, // reserved 2
		0x12, 0x34, 0x56, 0x7a, // reserved 3
		0x12, 0x34, 0x56, 0x7a, // reserved 4
		0x12, 0x34, 0x56, 0x7a, // reserved 5
		0x12, 0x34, 0x56, 0x7a, // reserved 6
		0x12, 0x34, 0x56, 0x7a, // reserved 7
	}

	for b.Loop() {
		ParseSocketHeader(data)
	}
}
